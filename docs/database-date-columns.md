# Database Date Columns Architecture

## Overview

The SpendCheck application uses two distinct date columns in the `spending_entries` table to serve different business and technical purposes.

## Date Columns Explained

### 1. `date` - Business/User Date

**Purpose:** Represents when the spending transaction actually occurred from the user's perspective.

**Characteristics:**
- **Type:** `timestamptz` (timezone-aware)
- **Default:** `NOW()` (server-generated UTC timestamp)
- **User Control:** User can modify this date (e.g., backdate expenses)
- **Business Logic:** Used for financial reporting, charts, and spending analysis

**Use Cases:**
- Grouping expenses by day/week/month in charts
- Financial reports and analytics
- User says "I bought coffee yesterday" → `date` = yesterday
- Backdating forgotten expenses

### 2. `created_at` - System Timestamp

**Purpose:** Audit trail timestamp showing when the record was created in the system.

**Characteristics:**
- **Type:** `timestamptz` (timezone-aware)
- **Default:** `NOW()` (automatic on insert)
- **User Control:** System-controlled, immutable
- **Technical Logic:** Used for data ordering, debugging, and audit trails

**Use Cases:**
- Sorting "recently added" entries
- Debugging data creation issues
- Audit compliance and data integrity
- System behavior analysis

## Real-World Example

```sql
-- User adds yesterday's coffee expense today
INSERT INTO spending_entries (
    user_id,
    amount,
    currency,
    category,
    date,      -- '2025-06-14' (when coffee was actually bought)
    created_at -- '2025-06-15' (when user entered it into app)
) VALUES (
    'user123',
    5.50,
    'USD',
    'Food & Dining',
    '2025-06-14 08:30:00+00',  -- Yesterday morning
    '2025-06-15 20:15:00+00'   -- Today evening (auto-generated)
);
```

## Frontend Usage

### Chart Display (uses `date`)
```typescript
// Group spending by actual spending date for charts
const chartData = entries.filter(entry => {
  const spendingDate = new Date(entry.date).toLocaleDateString('en-CA')
  return spendingDate === targetDate
})
```

### Recent Activity (uses `created_at`)
```typescript
// Show recently added entries
const recentEntries = entries
  .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
  .slice(0, 10)
```

## Alternative Approaches Considered

### Single Date Column Approaches

#### Option 1: Only `date`
**Pros:**
- Simpler schema
- Less storage overhead

**Cons:**
- ❌ No audit trail of data entry
- ❌ Cannot track user behavior patterns
- ❌ Difficult to debug data integrity issues
- ❌ Lost system accountability

#### Option 2: Only `created_at`
**Pros:**
- Automatic timestamp management
- Strong audit trail

**Cons:**
- ❌ Cannot backdate expenses
- ❌ Poor user experience (no flexibility)
- ❌ Charts show data entry time, not spending time
- ❌ Misleading financial reports

## Best Practices

### Database Level
```sql
-- Ensure both columns have proper defaults
ALTER TABLE spending_entries 
ALTER COLUMN date SET DEFAULT NOW(),
ALTER COLUMN created_at SET DEFAULT NOW();
```

### Application Level
```typescript
// When creating entries, let backend set created_at
const { data } = await supabase
  .from('spending_entries')
  .insert([{
    user_id: userId,
    amount: amount,
    currency: currency,
    date: userSpecifiedDate, // User can control this
    // created_at: auto-generated by database
  }])
```

### Frontend Display
```typescript
// Use appropriate date for context
const displayDate = showActualSpendingDate 
  ? entry.date      // For financial charts
  : entry.created_at // For activity logs
```

## Timezone Handling

Both columns use `timestamptz` and store data in UTC:

- **Backend:** Generates UTC timestamps with `NOW()`
- **Frontend:** Converts UTC to local timezone for display
- **User Experience:** Sees dates in their local timezone
- **Data Integrity:** All data stored consistently in UTC

## Conclusion

The dual-date approach provides:
- **User Flexibility:** Can backdate and correct spending dates
- **System Accountability:** Audit trail of when data was entered
- **Business Intelligence:** Accurate financial reporting
- **Technical Reliability:** Debugging and data integrity tools

This architecture is standard practice in financial applications and provides the best balance of user experience and system reliability.